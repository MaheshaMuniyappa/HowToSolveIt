                       ALGORITHM COMPUTERS    Exception Handling
                       -------------------    Topic - 12
An  Exception  is  an abnormal condition that arises  in  a  code 
sequence at run time. In other words, an exception is a run  time 
error. 
1] Exception-Handling Fundamentals:
-----------------------------------
     A Java exception is an object that describes an  exceptional 
(that  is, error) condition that has occured in a piece of  code. 
When an exceptional condition arises, an object representing that 
exception  is  created and thrown in the method that  caused  the 
error. That method may choose to handle the exception itself,  or 
pass  it on. Either way, at some point, the exception  is  caught 
and  processed. Exceptions can be generated by the Java  run-time 
system,  or  they  can  be  manually  generated  by  your   code. 
Exceptions  thrown  by  Java relate to  fundamental  errors  that 
violate the rules of Java language or the constraints of the Java 
execution   environment.   Manually  generated   exceptions   are 
typically used to report some error condition to the caller of  a 
method.
     Java exception handling is managed via five keywords:
try, catch, throw, throws, and finally. 
     This is the general form of exception-handling block:
try {
  // block of code to monitor for errors
}

catch(ExceptionType1 exOb) {
  // exception handler for Exception Type1
}

catch(ExceptionType2 exOb) {
  // exception handler for Exception Type2
}
//...
finally {
  // block of code to be executed before try block ends
}

2] Exception Types:
-------------------
                         Throwable
                             |
             --------------------------------------
             |                                    |
          Exception                             Error
             |
          RuntimeException

     All  exceptions are sub classes of Throwable. One branch  is 
headed  by 'Exception'. These exceptions should be  caught.  It's 
sub class is 'RuntimeException'. Exceptions of this type need not 
be caught, for example: division by zero etc.
     Error defines exceptions that are not expected to be  caught 
under normal circumstances by your program.
3] Uncaught Exceptions:
-----------------------
     Before  you learn how to handle exceptions in your  program, 
it is useful to see what happens when you don't handle them.

Ex1: Listing of 'Exec0.java'
----------------------------
//  This small program includes an exception  that  intentionally 
//  causes a divide-by-zero error.
//  The error printed will be explaining the exception
//  along with the line number.
class Exec0 {
        public static void main(String args[])
        {
                int d = 0;
                int a = 42/d;
                System.out.println("end of main");
        }
}

Ex2: Listing of 'Exec1.java':
-----------------------------
// The error printed shows the resulting call stack.
class Exec1 {
        static void subroutine() {
                int d = 0;
                int a = 42/d;
                System.out.println("end of main");
        }
        public static void main(String args[])
        {
                Exec1.subroutine();     
        }
}

[4] Using try and catch:
------------------------
     Although the default exception handler provided by the  Java 
run-time system is useful for debugging, you will want to  handle 
an exception yourself. Doing so provides two benefits. First,  it 
allows you to fix the error. Second, it prevents the program from 
automatically terminating. 

Ex: Listing of Exec2.java:
--------------------------
class Exec2 {
        public static void main(String args[])
        {
                int d,a;
                try
                {
                  d = 0;
                  a = 42/d;
                  System.out.println("This will not be printed..");
                }
                catch(ArithmeticException e)
                {
                        System.out.println("Division by Zero");
                }
                
                System.out.println("After catch statement");
        }
}

[4.a] Displaying the Description of an Exception:
-------------------------------------------------
     Replace the catch block in the above program as:
catch(ArithmeticException e) {
  System.out.println("Exception: " + e);
  a = 0; // set a zero and continue
}

[5] Multiple catch Clauses:
---------------------------
     In some cases, more than one exception could be raised by  a 
single  piece of code. To handle this type of situation, you  can 
specify two or more catch clauses, each catching a different type 
of exception. The following example traps two different exception 
types.

Ex: Listing of 'MultiCatch.java':
---------------------------------
class MultiCatch {
        public static void main(String args[])
        {
                try {
                        int a = args.length;
                        System.out.println("a = "+a);
                        int b = 42/a;
                        int c[] = {1};
                        c[42] = 99;
                }
                catch (ArithmeticException e)
                {
                        System.out.println("Divide by 0 : " + e);
                }
                catch (ArrayIndexOutOfBoundsException e)
                {
                        System.out.println("Array Index oob: " + e);
                }
        }
}








[5.a] Order of catch statements:
--------------------------------
     When  you use multiple catch statements, it is important  to 
remember that exception subclasses must come before any of  their 
superclasses.  This  is  because a catch statement  that  uses  a 
superclass  will  catch exceptions of that type plus any  of  its 
subclasses.  Thus, a subclass would never be reached if  it  came 
after  its superclass. Further, in Java, unreachable code  is  an 
error. For example, consider the following program:

Ex: Listing of 'SuperSubCatch.java':
------------------------------------
/* This program contains an error
A subclass must come before its superclass in
a series of catch statements. If not,
unreachble code will be created and a 
compile-time error will result.
*/
        
class SuperSubCatch {
        public static void main(String args[]) {
                 try
                 {
                        int a = 0;
                        int b = 42/a;
                 } 
                 catch(Exception e) 
                 {
                   System.out.println("generic exception catch.");
                 }
                 /* This catch is never reached because
        ArithmeticException is a subclass of Exception. */
                                        
                 catch(ArithmeticException e) 
                 {
                   System.out.println("This is never reached.");
                 }
        }
}

[6] throw:
----------
     Apart  from Java run time exceptions it is also possible  to 
throw an exception explicitly. 
     Ex: throw ThrowableInstance
Here, ThrowableInstance must be an object of type Throwable or  a 
subclass of Throwable. Simple types, such as int or char, as well 
as  non-Throwable classes, such as String and Object,  cannot  be 
used as exceptions. There are two ways you can obtain a Throwable 
object: using a parameter into catch clause, or creating one with 
the new operator.
     The  flow  of execution stops immediately  after  the  throw 
statement; any subsequent statements are not executed. 


Ex: Listing of 'ThrowDemo.java':
--------------------------------
class ThrowDemo
{
        static void demoproc()
        {
                try
                {
                        throw new NullPointerException("demo");
                }
                catch(NullPointerException e)
                {
                        System.out.println("Caught inside demoproc.");
                        throw e;
                }
        }
        public static void main(String args[])
        {
                try
                {
                        demoproc();
                }
                catch(NullPointerException e)
                {
                        System.out.println("Recaught: " + e);
                }
        }
}
[7] throws:
-----------
     If a method is capable of causing an exception that it  does 
not handle, it must specify this behavior so that callers of  the 
method  can guard themselves against that exception. You do  this 
by including a throws clause in the method's declaration. This is 
necessary  for  all  exceptions, except those of  type  Error  or 
RuntimeException,   or  any  of  their  subclasses.   All   other 
exceptions that a method can throw must be declared in the throws 
clause. If they are not, a compile time error will result.

Ex1: Listing of ThrowsDemo.java:
-------------------------------
// This program contains an error and will not compile.

class ThrowsDemo
{
        static void throwOne()
        {
                System.out.println("Inside throwOne.");
                throw new IllegalAccessException("demo");
        }
        public static void main(String args[])
        {
                throwOne();
        }
}
Ex2: Listing of ThrowsDemo1.java:
---------------------------------
// This program ducks an Exception.
// The Exception is passed to call stack

class ThrowsDemo1
{
        static void throwOne() throws IllegalAccessException
        {
                System.out.println("Inside throwOne.");
                throw new IllegalAccessException("demo");
        }
        public static void main(String args[]) 
                    throws IllegalAccessException
        {
                throwOne();
                System.out.println("End of main");
        }
}

Ex3: Listing of 'ThrowsDemo2.java':
-----------------------------------
// This program ducks an Exception.
// The Exception is passed to call stack
// The exception is handled in main method.
class ThrowsDemo2
{
        static void throwOne() throws IllegalAccessException
        {
                System.out.println("Inside throwOne.");
                throw new IllegalAccessException("demo");
        }
        public static void main(String args[])
        {
                try
                {
                        throwOne();
                }
                catch (IllegalAccessException e)
                {
                        System.out.println("Caught " + e);
                }
                System.out.println("End of main");
        }
}

[8] finally:
------------
     When  exceptions are thrown, execution in a method  takes  a 
rather abrupt, nonlinear path that alters the normal flow through 
the  method. Depending upon how the method is called, it is  even 
possible  for  an  exception  to  cause  the  method  to   return 
prematurely.  This  could  be  a problem  in  some  methods.  For 
example,  if a method opens a file upon entry and closes it  upon 
exit, then you will not want the code that closes the file to  be 
bypasses by the exception-handling mechanism. The finally keyword 
is designed to address this contingency.
Ex: Listing of 'FinallyDemo.java':
----------------------------------
class FinallyDemo
{
        static void procA()
        {
                try
                {
                        System.out.println("Inside procA");
                        throw new RuntimeException("demo");
                }
                finally
                {
                        System.out.println("procA's finally");
                }
        }
        
        public static void main(String args[])
        {
                try {
                        procA();
                }
                catch(Exception e)
                {
                        System.out.println("Exception caught");
                }
        }
}

[9] Java's Built-in Exceptions:
-------------------------------
[9.a] Unchecked Exceptions: (These exceptions need not be caught)
-----------------------------------------------------------------
ArithmeticException
ArrayIndexOutOfBoundsException
ArrayStoreException
ClassCastException
IllegalArgumentException
IllegalMonitorStateException
IllegalStateException
IllegalThreadStateException
IndexOutOfBoundsException
NegativeArraySizeException
NullPointerException
NumberFormatException
SecurityException
StringIndexOutOfBounds
UnsupportedOperationException







[9.b] Checked Exceptions: (These exceptions should be caught)
-------------------------------------------------------------
ClassNotFoundException
CloneNotSupportedException
IllegalAccessException
InstantiationException
InterruptedException
NoSuchFieldException
NoSuchMethodException

[10] Creating Your Own Exceptions:
----------------------------------
     Although  Java's  built-in  exceptions  handle  most  common 
errors, you will probably want to create your own exception types 
to  handle  situations specific to your applications. To  do  so, 
just define a subclass of Exception.
     The  following methods can be overriden when you write  your 
own exceptions:

Throwable fillInStackTrace()
String getLocalizeMessage()
String getMessage()
void printStackTrace()
void printStackTrace(PrintStream stream)
void printStackTrace(PrintWriter stream)
String toString()

Ex: Listing of 'ExceptionDemo.java':
------------------------------------
// This program creates a custom exception type.
class MyException extends Exception
{
        private int detail;
        
        MyException(int a)
        {
                detail = a;
        }
        
        public String toString()
        {
                return "MyException[" + detail + "]";
        }
}
class ExceptionDemo 
{
        static void compute(int a) throws MyException
        {
                System.out.println("Called compute(" + a + ")");
                if(a > 10)
                        throw new MyException(a);
                System.out.println("Normal exit");
        }
        

        public static void main(String args[])
        {
                try {
                        compute(1);
                        compute(20);
                }
                catch(MyException e)
                {
                        System.out.println("Caught " + e);
                }
        }
}












































