                       ALGORITHM COMPUTERS    Advanced GUI
                       -------------------    Topic - 10
1] EVENTS:
----------
     The two models of Event Handling are:
     a) Outward Rippling model
     b) Event Delegation Model

1.1] Motivation for the new model:
----------------------------------
     Certain  flawa in the original event model  became  apparent 
after  Java had been in the world long enough for large  programs 
to be developed.
     The major problem was that an event could only be handled by 
the  component  that  originated  the event  or  by  one  of  the 
containers   that  contained  the  originating  component.   This 
restriction violated one of the fundamental principles of object-
oriented  programming:  Functionality should reside in  the  most 
appropriate class. Often the most appropriate class for  handling 
an  event  is  not  a  member  of  the  originating   component's 
containment hierarchy.
     Another  drawback  of the original model was  that  a  large 
number  of  CPU cycles were wasted on uninteresting  events.  Any 
event in which a program had no interest would ripple all the way 
through   the  containment  hierarchy  before  eventually   being 
discarded.  The  original  model  provided  no  way  to   disable 
processing of irrelelevant events.
     In  the new delegation model, a component may be told  which 
object or objects should be notified when the component generates 
a  particular kind of event. If a component is not interested  in 
an event type, then events of that type will not be propagated.

     The delegation model is based on four concepts:
     a) Event Classes
     b) Event Listeners
     c) Explicit event enabling
     d) Adapters

1.2] The Event Classes:(All classes belong to java.awt.event package)
-----------------------
                              java.util.EventObject
                                       |
     -------------------------------------------------------------
    |              |                  |              |           |
ActionEvent  AdjustmentEvent    ComponentEvent   ItemEvent   TextEvent     
                                      |
                                      |
    -------------------------------------------------------------
    |                |                |             |            |
ContainerEvent   FocusEvent       InputEvent    PaintEvent WindowEvent
                                      |
                                      |
                          --------------------------
                          |                        |
                      KeyEvent                  MouseEvent
1.3] The various Event types:
-----------------------------

ActionEvent: generated by activation of components
AdjustmentEvent: generated by adjustment of adjustable components
                 such as scroll bars.
ContainerEvent: generated when components are added to or removed
                from a container.
FocusEvent: generated when a component receives input focus.
ItemEvent:  generated  when  an item is  selected  from  a  list, 
            choice, or check box.
KeyEvent: generated by keyboard activity.
MouseEvent: generated by mouse activity.
PaintEvent: generated when a component is painted.
TextEvent: generated when a text component is modified.
WindowEvent: generated by window activity (such as iconifying
             or de-iconifying).

1.4] Event Listeners:
---------------------
interface                      interface method
----------                     ----------------
ActionListener                 actionPerformed
AdjustmentListener             adjustmentValueChanged
ComponentListener              componentHidden  etc
ContainerListener              componentAdded etc
FocusListener                  focusGained etc
ItemListener                   itemStateChanged
KeyListener                    keyPressed etc
MouseListener                  mouseClicked etc
MouseMotionListener            mouseDragged etc
TextListener                   textValueChanged 
WindowListener                 windowActivated etc

Refer to earlier notes for event listeners examples.

1.5] Explicit Event Enabling:
-----------------------------

Example code:
-------------
class MyBtn extends Button {
  public MyBtn(String label) {
    super(label);
    enableEvents(AWTEvent.ACTION_EVENT_MASK);
  }

  public void processActionEvent(ActionEvent ae) {
    System.out.println("Processing an action event.");
    super.processActionEvent(ae);
  }
}



1.6] Adapters:
--------------
When  an  interface  is  implemented, all  the  methods that  are 
contained  in  the  interface must be implemented.  This  can  be 
avoided by using adapters. The adapter of a particular  interface 
provides  dummy methods for all the methods of  interface.  While 
extending the adapter, it is enough to write the functions of our 
interest.

class MyListener extends WindowAdapter {
  public void windowIconified(WindowEvent we) {
    // process the event
  }
}

Adapters:
---------
ComponentAdapter
ContainerAdapter
FocusAdapter
KeyAdapter
MouseAdapter
MouseMotionAdapter
WindowAdapter































[2] Listing of 'TextAreaDemo.java'
// TextAreaDemo.java
// Copying selected text from one text area to another.
import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;

public class TextAreaDemo extends Applet
      implements ActionListener, TextListener {
   private TextArea t1, t2;
   private Button copy;

   public void init() 
   {
      String s = "This is a demo string to illustrate " +
                 "copying text from one TextArea to " +
                 "another TextArea using an external event";

      t1 = new TextArea( s, 5, 20, TextArea.SCROLLBARS_NONE );
      t1.addTextListener( this );
      add( t1 );

      copy = new Button( "Copy >>>" );
      copy.addActionListener( this );
      add( copy );

      t2 = new TextArea( 5, 20 );
      t2.setEditable( false );
      add( t2 );
   }

   public void actionPerformed( ActionEvent e )
   {
      t2.setText( t1.getSelectedText() );
   }

   public void textValueChanged( TextEvent e )
   {
      TextComponent source = ( TextComponent ) e.getSource();
      t2.setText( source.getText() );
   }
}













[3] Listing of 'ScrollbarDemo.java'
// ScrollbarDemo.java
// Using Scrollbars to size an oval.
import java.applet.Applet;
import java.awt.*;

public class ScrollbarDemo extends Applet {
   private Scrollbar scrollHeight, scrollWidth;
   private OvalCanvas c;

   public void init() 
   {
      setSize( 215, 235 );

      c = new OvalCanvas();
      c.setSize( 200, 200 );
      c.setBackground( Color.yellow );

      scrollHeight = new Scrollbar( Scrollbar.VERTICAL, 100,
                                    1, 0, 200 );
      scrollHeight.addAdjustmentListener(
         new ScrollbarHandler( c, OvalCanvas.HEIGHT ) );

      scrollWidth = new Scrollbar( Scrollbar.HORIZONTAL, 100,
                                   1, 0, 200 );
      scrollWidth.addAdjustmentListener(
         new ScrollbarHandler( c, OvalCanvas.WIDTH ) );

      setLayout( null );  // No layout 

      add( scrollHeight );
      scrollHeight.setBounds( 200, 0, 15, 200 );

      add( scrollWidth );
      scrollWidth.setBounds( 0, 200, 200, 15 );

      add( c );
      c.setLocation( 0, 0 );
   }
}
[3.a] Listing of 'OvalCanvas.java'
// OvalCanvas.java
// A customized Canvas class.
import java.awt.*;

public class OvalCanvas extends Canvas {
   public static int WIDTH = 1, HEIGHT = 2;
   private int ovalWidth, ovalHeight;

   public OvalCanvas()
   {
      setOvalWidth( 100 );
      setOvalHeight( 100 );
   }

   public void paint( Graphics g )
   {
      g.drawOval( 0, 0, ovalWidth, ovalHeight );
   }

   public void setOvalWidth( int w )
   {
      ovalWidth = w;
      repaint();
   }

   public void setOvalHeight( int h )
   {
      ovalHeight = h;
      repaint();
   }
}
[3.b] Listing of 'ScrollbarHandler.java'
// ScrollbarHandler.java
// Class to handle Scrollbar events.
import java.awt.event.*;

public class ScrollbarHandler implements AdjustmentListener {
   private OvalCanvas canvas;
   private int dimension;

   public ScrollbarHandler( OvalCanvas c, int d )
   {
      canvas = c;
      dimension = d;
   }

   public void adjustmentValueChanged( AdjustmentEvent e )
   {
      if ( dimension == OvalCanvas.WIDTH ) 
         canvas.setOvalWidth( e.getValue() );
      else if ( dimension == OvalCanvas.HEIGHT ) 
         canvas.setOvalHeight( e.getValue() );
   }
}















[4] Listing of 'MyFrame.java'
// MyFrame.java
// Creating a subclass of Frame.
import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;
//import com.deitel.jhtp2.ch11.ColorFrame;

public class MyFrame extends Applet implements ActionListener {
   private ColorFrame f;
   private Button showFrame;

   public void init() 
   {
      showFrame = new Button( "Show frame" );
      add( showFrame );
      showFrame.addActionListener( this );

      f = new ColorFrame( "Select a color" );
   }

   public void actionPerformed( ActionEvent e )
   {
      f.setVisible( true );  // show the frame
   }
}

[4.a] Listing of 'CloseWindow.java'
// CloseWindow.java
// Class to close a window.
import java.awt.event.*;

public class CloseWindow extends WindowAdapter {
   public void windowClosing( WindowEvent e )
   {
      e.getWindow().setVisible( false );
   }
}

[4.b] Listing of 'ColorFrame.java'
// ColorFrame.java
// ColorFrame class allows user to select a color and
// changes the frame's background to that color.
//package com.deitel.jhtp2.ch11;
import java.awt.*;
import java.awt.event.*;

public class ColorFrame extends Frame implements ItemListener {
   private Color colors[] = { Color.white, Color.red,
      Color.green, Color.blue, Color.magenta };
   private String colorNames[] =
      { "White", "Red", "Green", "Blue", "Magenta" };
   private Choice colorChoice;


   public ColorFrame( String s )
   {
      // call base class constructor
      super( s );
      setSize( 275, 150 );
      addWindowListener( new CloseWindow() );

      colorChoice = new Choice();

      for ( int i = 0; i < colorNames.length; i++ )
         colorChoice.add( colorNames[ i ] );

      add( colorChoice, BorderLayout.NORTH );
      colorChoice.addItemListener( this );
   }

   public void itemStateChanged( ItemEvent e )
   {
      setBackground( colors[ colorChoice.getSelectedIndex() ] );
      repaint();
   }
}

[5] Listing of 'ScratchPad.java'
// ScratchPad.java
// Incorporating menus into a subclass of Frame.
import java.awt.*;
import java.awt.event.*;

public class ScratchPad extends Frame
      implements ActionListener, ItemListener {
   private TextArea t;
   private String fontNames[] =
      { "TimesRoman", "Courier", "Helvetica" };
   private String colorNames[] =
      { "Black", "Red", "Green", "Blue" };
   private Color colorValues[] =
      { Color.black, Color.red, Color.green, Color.blue };

   private MenuBar bar;
   private Menu formatMenu, fontMenu, colorMenu;
   private MenuItem fonts[], colors[];
   private CheckboxMenuItem readOnly;

   public ScratchPad() 
   {
      super( "ScratchPad Application" );
      setSize( 300, 200 );

      t = new TextArea( "", 2, 20,
                        TextArea.SCROLLBARS_VERTICAL_ONLY);
      add( t, BorderLayout.CENTER );

      t.setFont( new Font( "TimesRoman", Font.PLAIN, 12 ) );
      t.setForeground( colorValues[ 0 ] );

      // create menubar
      bar = new MenuBar();

      // create the format menu
      formatMenu = new Menu( "Format" );

      // create font menu
      fontMenu = new Menu( "Font" );

      fonts = new MenuItem[ fontNames.length ];

      for ( int i = 0; i < fonts.length; i++ ) {
         fonts[ i ] = new MenuItem( fontNames[ i ] );
         fontMenu.add( fonts[ i ] );
         fonts[ i ].addActionListener( this );
      }

      formatMenu.add( fontMenu );
      formatMenu.addSeparator();

      // create color menu
      colorMenu = new Menu( "Color" );

      colors = new MenuItem[ colorNames.length ];

      for ( int i = 0; i < colors.length; i++ ) {
         colors[ i ] = new MenuItem( colorNames[ i ] );
         colorMenu.add( colors[ i ] );
         colors[ i ].addActionListener( this );
      }

      formatMenu.add( colorMenu );
      formatMenu.addSeparator();

      // create "read-only" menu item
      readOnly = new CheckboxMenuItem( "Read-Only" );
      readOnly.addItemListener( this );

      formatMenu.add( readOnly );

      // add menu to menu bar
      bar.add( formatMenu );

      // set the menubar for the frame
      setMenuBar( bar );
 
      setVisible( true );
   }






   // Handle font and color menu selections
   public void actionPerformed( ActionEvent e )
   {
      for ( int i = 0; i < fonts.length; i++ )
         if ( e.getSource() == fonts[ i ] ) {
            t.setFont( new Font( fonts[ i ].getLabel(),
               Font.PLAIN, 12 ) );
            break;
         }

      for ( int i = 0; i < colors.length; i++ )
         if ( e.getSource() == colors[ i ] ) {
            t.setForeground( colorValues[ i ] );
            break;
         }
   }

   // Handle "read-only" menu selections
   public void itemStateChanged( ItemEvent e )
   {
      t.setEditable( ! t.isEditable() );
   }
}

[5.a] Listing of 'ScratchPadTest.java'
// ScratchPadTest.java
// Class to test ScratchPad.

public class ScratchPadTest {
   public static void main( String args[] )
   {
      ScratchPad e = new ScratchPad();
      e.addWindowListener( new CloseWindowAndExit() );
   }
}

5.b] Listing of CloseWindowAndExit.java

import java.awt.event.*;

public class CloseWindowAndExit extends WindowAdapter {
   public void windowClosing( WindowEvent e )
   {
      System.exit( 0 );
   }
}
